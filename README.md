# rePong

Thank you for taking a look at this project! "rePong" is a new rendition of the classic game Pong developed as part of the AP Computer Science Principles assessment. It features the ability to charge up power before reflecting the ball, the ability for the the ball to go off the screen, a gradually increasing pace, and an entirely singleplayer experience.

In terms of design, the biggest challenge I encountered with this project was devising how to make a fundamentally multiplayer game singlplayer without the use of sophistcated AI, as this was meant to be a much smaller scale venture and at this point in time I am not entirely confident with managing multiplayer systems, let alone implementing some version of machine learning into a Unity project. Because the "AI" for this game simply follows the exact position of the ball at a fixed rate, I originally settled for an endless version of the game, where score was calculated based off the amount of time the player "survives." But even to me, the need to outlast a perfect bot in a simple game of Pong didn't seem like much fun.

Although the quote "it's not a bug, its a feature" is almost always perceieved as a joke in the game development community, I had never considered its potential validity unitl developing this game. While trying to balance the element where the ball speed gradually rises as each player hits it, I accidentally phased the ball through the bot's paddle once it had got to a high enough speed. At first, it didn't occur to me why this happened, because I could still easily see the ball's movement at that speed. However, I realized later that it was because I was using a much simpler verison of collision detection based on the ball's position rather than using Unity's standard Collider component. I opted for this earlier because I knew that I would want to be able to affect the ball's trajectory much more freely after a collision, but also to simply gain more programming experience by not relying on too many built in systems. Lucky for me, this system also allowed my game to be more like an actual game of Pong, where now it was a contest to see who could make the ball reach a winning speed first, which was also fair enough for the player since the bot is not able to use the "charge shot" feature.

The greatest opportunity I saw in developing this game from that point on was to learn to depend on my own abilities more often, even if they aren't conventional at times or the absolute best possible solution. While built-in tools for game engines are very useful for larger projects, I feel the limits I placed on myself for the development of this one actually forced my hand at creativity much further, and I also had the addditional benefit of knowing my own code much more than the entirety of the Unity engine. Another example of this ended up actually providing a more efficient solution for a problem I have attempted previously. In the past, I have used the Stopwatch C# object to make a cooldown for abilities, enemy spawning, or etc. I had always became slightly infuriated having to calculate milliseconds, working with the Stopwatch functions, as well as having an entirely new Object to initialize and possibly have to fulfill dependencies for. This time, I used a simple float value that was chipped away by the Time.deltaTime function in the Update loop, reset it each time the player uses the specified ability, and allow the player to use the ability again once that float reaches 0 or below.

While there are still many more opportunities within this project to clean up code and seek out more features, I am confident in the overall success that I had in completing a working game in a relatively short amount of time, and I hope you get a bit of enjoyment and insight out of my experiences and maybe even the game itself.
